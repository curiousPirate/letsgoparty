#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const process_1 = require("process");
const yargs_1 = __importDefault(require("yargs"));
const main_1 = require("./main");
// CLI entry point
const runCli = function () {
    return __awaiter(this, void 0, void 0, function* () {
        // @ts-expect-error TODO: `destFolder` and  `srcFolder` are not being passed
        // back from `parseArgs()`.
        const _a = parseArgs(), { destFolder, srcFolder } = _a, options = __rest(_a, ["destFolder", "srcFolder"]);
        try {
            // @ts-expect-error TODO: `options` is not getting the right types.
            const zipped = yield (0, main_1.zipFunctions)(srcFolder, destFolder, options);
            console.log(JSON.stringify(zipped, null, 2));
        }
        catch (error) {
            console.error(error.toString());
            (0, process_1.exit)(1);
        }
    });
};
const parseArgs = function () {
    return yargs_1.default
        .command('* <srcFolder> <destFolder>', 'Create ZIP archives from a directory')
        .options(OPTIONS)
        .usage(USAGE)
        .strict()
        .parse();
};
const archiveFormats = ['none', 'zip'];
const defaultArchiveFormat = 'zip';
const OPTIONS = {
    'archive-format': {
        string: true,
        choices: archiveFormats,
        default: defaultArchiveFormat,
        describe: 'Format of the archive created for each function',
    },
    config: {
        default: {},
        describe: 'An object matching glob-like expressions to objects containing configuration properties. Whenever a function name matches one of the expressions, it inherits the configuration properties',
    },
    manifest: {
        string: true,
        describe: 'If a manifest file is to be created, specifies its path',
    },
    'parallel-limit': {
        number: true,
        describe: 'Maximum number of Functions to bundle at the same time',
    },
};
const USAGE = `$0 [OPTIONS...] FUNCTIONS_DIRECTORY OUTPUT_DIRECTORY

Zip all function files inside FUNCTIONS_DIRECTORY so that they can be uploaded
to AWS Lambda.`;
runCli();
//# sourceMappingURL=bin.js.map