"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkdirAndWriteFile = exports.readFile = exports.writeFile = exports.stat = exports.safeUnlink = exports.resolveFunctionsDirectories = exports.listFunctionsDirectory = exports.listFunctionsDirectories = exports.getPathWithExtension = exports.lstat = exports.cachedReadFile = exports.cachedReaddir = exports.cachedLstat = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const make_dir_1 = __importDefault(require("make-dir"));
const non_nullable_1 = require("./non_nullable");
const pLstat = (0, util_1.promisify)(fs_1.lstat);
exports.lstat = pLstat;
const pReaddir = (0, util_1.promisify)(fs_1.readdir);
const pReadFile = (0, util_1.promisify)(fs_1.readFile);
exports.readFile = pReadFile;
const pStat = (0, util_1.promisify)(fs_1.stat);
exports.stat = pStat;
const pUnlink = (0, util_1.promisify)(fs_1.unlink);
const pWriteFile = (0, util_1.promisify)(fs_1.writeFile);
exports.writeFile = pWriteFile;
// This caches multiple FS calls to the same path. It creates a cache key with
// the name of the function and the path (e.g. "readdir:/some/directory").
//
// TODO: This abstraction is stripping out some type data. For example, when
// calling `readFile` without an encoding, the return type should be narrowed
// down from `string | Buffer` to `Buffer`, but that's not happening.
const makeCachedFunction = (func) => (cache, path, ...args) => {
    const key = `${func.name}:${path}`;
    if (cache[key] === undefined) {
        // eslint-disable-next-line no-param-reassign
        cache[key] = func(path, ...args);
    }
    return cache[key];
};
const cachedLstat = makeCachedFunction(pLstat);
exports.cachedLstat = cachedLstat;
const cachedReaddir = makeCachedFunction(pReaddir);
exports.cachedReaddir = cachedReaddir;
const cachedReadFile = makeCachedFunction(pReadFile);
exports.cachedReadFile = cachedReadFile;
const getPathWithExtension = (path, extension) => (0, path_1.format)(Object.assign(Object.assign({}, (0, path_1.parse)(path)), { base: undefined, ext: extension }));
exports.getPathWithExtension = getPathWithExtension;
const safeUnlink = (path) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield pUnlink(path);
    }
    catch (_) { }
});
exports.safeUnlink = safeUnlink;
// Takes a list of absolute paths and returns an array containing all the
// filenames within those directories, if at least one of the directories
// exists. If not, an error is thrown.
const listFunctionsDirectories = function (srcFolders) {
    return __awaiter(this, void 0, void 0, function* () {
        const filenamesByDirectory = yield Promise.all(srcFolders.map((srcFolder) => __awaiter(this, void 0, void 0, function* () {
            try {
                const filenames = yield listFunctionsDirectory(srcFolder);
                return filenames;
            }
            catch (error) {
                return null;
            }
        })));
        const validDirectories = filenamesByDirectory.filter(non_nullable_1.nonNullable);
        if (validDirectories.length === 0) {
            throw new Error(`Functions folder does not exist: ${srcFolders.join(', ')}`);
        }
        return validDirectories.flat();
    });
};
exports.listFunctionsDirectories = listFunctionsDirectories;
const listFunctionsDirectory = function (srcFolder) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const filenames = yield pReaddir(srcFolder);
            return filenames.map((name) => (0, path_1.join)(srcFolder, name));
        }
        catch (error) {
            throw new Error(`Functions folder does not exist: ${srcFolder}`);
        }
    });
};
exports.listFunctionsDirectory = listFunctionsDirectory;
const resolveFunctionsDirectories = (input) => {
    const directories = Array.isArray(input) ? input : [input];
    const absoluteDirectories = directories.map((srcFolder) => (0, path_1.resolve)(srcFolder));
    return absoluteDirectories;
};
exports.resolveFunctionsDirectories = resolveFunctionsDirectories;
const mkdirAndWriteFile = (path, ...params) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof path === 'string') {
        const directory = (0, path_1.dirname)(path);
        yield (0, make_dir_1.default)(directory);
    }
    return pWriteFile(path, ...params);
});
exports.mkdirAndWriteFile = mkdirAndWriteFile;
//# sourceMappingURL=fs.js.map