"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunctionsFromPaths = void 0;
const path_1 = require("path");
const config_1 = require("../config");
const feature_flags_1 = require("../feature_flags");
const go_1 = __importDefault(require("./go"));
const node_1 = __importDefault(require("./node"));
const rust_1 = __importDefault(require("./rust"));
/**
 * Finds functions for a list of paths using a specific runtime. The return
 * value is an object containing an array of the functions found (`functions`)
 * and an array with the paths that haven't been recognized by the runtime
 * (`remainingPaths`).
 */
const findFunctionsInRuntime = function ({ dedupe = false, featureFlags, fsCache, paths, runtime, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const functions = yield runtime.findFunctionsInPaths({ featureFlags, fsCache, paths });
        // If `dedupe` is true, we use the function name (`filename`) as the map key,
        // so that `function-1.js` will overwrite `function-1.go`. Otherwise, we use
        // `srcPath`, so that both functions are returned.
        const key = dedupe ? 'name' : 'srcPath';
        // Augmenting the function objects with additional information.
        const augmentedFunctions = functions.map((func) => [
            func[key],
            Object.assign(Object.assign({}, func), { extension: (0, path_1.extname)(func.mainFile), filename: (0, path_1.basename)(func.srcPath), runtime }),
        ]);
        const usedPaths = new Set(augmentedFunctions.map(([path]) => path));
        const remainingPaths = paths.filter((path) => !usedPaths.has(path));
        return { functions: augmentedFunctions, remainingPaths };
    });
};
/**
 * Gets a list of functions found in a list of paths.
 */
const getFunctionsFromPaths = (paths, { config, dedupe = false, featureFlags = feature_flags_1.defaultFlags, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    // An object to cache filesystem operations. This allows different functions
    // to perform IO operations on the same file (i.e. getting its stats or its
    // contents) without duplicating work.
    const fsCache = {};
    // The order of this array determines the priority of the runtimes. If a path
    // is used by the first time, it won't be made available to the subsequent
    // runtimes.
    const runtimes = [node_1.default, go_1.default, rust_1.default];
    // We cycle through the ordered array of runtimes, passing each one of them
    // through `findFunctionsInRuntime`. For each iteration, we collect all the
    // functions found plus the list of paths that still need to be evaluated,
    // using them as the input for the next iteration until the last runtime.
    const { functions } = yield runtimes.reduce((aggregate, runtime) => __awaiter(void 0, void 0, void 0, function* () {
        const { functions: aggregateFunctions, remainingPaths: aggregatePaths } = yield aggregate;
        const { functions: runtimeFunctions, remainingPaths: runtimePaths } = yield findFunctionsInRuntime({
            dedupe,
            featureFlags,
            fsCache,
            paths: aggregatePaths,
            runtime,
        });
        return {
            functions: [...aggregateFunctions, ...runtimeFunctions],
            remainingPaths: runtimePaths,
        };
    }), Promise.resolve({ functions: [], remainingPaths: paths }));
    const functionsWithConfig = functions.map(([name, func]) => [
        name,
        Object.assign(Object.assign({}, func), { config: (0, config_1.getConfigForFunction)({ config, func }) }),
    ]);
    return new Map(functionsWithConfig);
});
exports.getFunctionsFromPaths = getFunctionsFromPaths;
//# sourceMappingURL=index.js.map