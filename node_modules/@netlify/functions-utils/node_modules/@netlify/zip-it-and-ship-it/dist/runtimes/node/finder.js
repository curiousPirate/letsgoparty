"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunctionAtPath = exports.findFunctionsInPaths = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const locate_path_1 = __importDefault(require("locate-path"));
const non_nullable_1 = require("../../utils/non_nullable");
const pLstat = (0, util_1.promisify)(fs_1.lstat);
// List of extensions that this runtime will look for, in order of precedence.
const allowedExtensions = ['.js', '.zip', '.cjs', '.mjs', '.ts'];
// Sorting function, compatible with the callback of Array.sort, which sorts
// entries by extension according to their position in `allowedExtensions`.
// It places extensions with a higher precedence last in the array, so that
// they "win" when the array is flattened into a Map.
const sortByExtension = (fA, fB) => {
    const indexA = allowedExtensions.indexOf(fA.extension);
    const indexB = allowedExtensions.indexOf(fB.extension);
    return indexB - indexA;
};
const findFunctionsInPaths = function ({ paths }) {
    return __awaiter(this, void 0, void 0, function* () {
        const functions = yield Promise.all(paths.map(getFunctionAtPath));
        // It's fine to mutate the array since its scope is local to this function.
        const sortedFunctions = functions.filter(non_nullable_1.nonNullable).sort((fA, fB) => {
            // We first sort the functions array to put directories first. This is so
            // that `{name}/{name}.js` takes precedence over `{name}.js`.
            const directorySort = Number(fA.stat.isDirectory()) - Number(fB.stat.isDirectory());
            if (directorySort !== 0) {
                return directorySort;
            }
            // If the functions have the same name, we sort them according to the order
            // defined in `allowedExtensions`.
            if (fA.name === fB.name) {
                return sortByExtension(fA, fB);
            }
            return 0;
        });
        return sortedFunctions;
    });
};
exports.findFunctionsInPaths = findFunctionsInPaths;
const getFunctionAtPath = function (srcPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const filename = (0, path_1.basename)(srcPath);
        if (filename === 'node_modules') {
            return;
        }
        const stat = yield pLstat(srcPath);
        const mainFile = yield getMainFile(srcPath, filename, stat);
        if (mainFile === undefined) {
            return;
        }
        const extension = (0, path_1.extname)(srcPath);
        const srcDir = stat.isDirectory() ? srcPath : (0, path_1.dirname)(srcPath);
        const name = (0, path_1.basename)(srcPath, (0, path_1.extname)(srcPath));
        return { extension, filename, mainFile, name, srcDir, srcPath, stat };
    });
};
exports.getFunctionAtPath = getFunctionAtPath;
// Each `srcPath` can also be a directory with an `index` file or a file using
// the same filename as its directory.
const getMainFile = function (srcPath, filename, stat) {
    return __awaiter(this, void 0, void 0, function* () {
        if (stat.isDirectory()) {
            return yield (0, locate_path_1.default)([
                (0, path_1.join)(srcPath, `${filename}.js`),
                (0, path_1.join)(srcPath, 'index.js'),
                (0, path_1.join)(srcPath, `${filename}.mjs`),
                (0, path_1.join)(srcPath, 'index.mjs'),
                (0, path_1.join)(srcPath, `${filename}.ts`),
                (0, path_1.join)(srcPath, 'index.ts'),
            ], { type: 'file' });
        }
        const extension = (0, path_1.extname)(srcPath);
        if (allowedExtensions.includes(extension)) {
            return srcPath;
        }
    });
};
//# sourceMappingURL=finder.js.map