"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSrcFiles = void 0;
/* eslint-disable max-lines */
const path_1 = require("path");
const junk_1 = require("junk");
const precinct_1 = __importDefault(require("precinct"));
const non_nullable_1 = require("../../../../utils/non_nullable");
const included_files_1 = require("../../utils/included_files");
const package_json_1 = require("../../utils/package_json");
const traversal_cache_1 = require("../../utils/traversal_cache");
const list_imports_1 = require("./list_imports");
const resolve_1 = require("./resolve");
const traverse_1 = require("./traverse");
const tree_files_1 = require("./tree_files");
const tree_shake_1 = require("./tree_shake");
// Retrieve the paths to the Node.js files to zip.
// We only include the files actually needed by the function because AWS Lambda
// has a size limit for the zipped file. It also makes cold starts faster.
const getSrcFiles = function ({ config, featureFlags, mainFile, name, pluginsModulesPath, srcDir, srcPath, stat, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { includedFiles = [], includedFilesBasePath } = config;
        const { exclude: excludedPaths, paths: includedFilePaths } = yield (0, included_files_1.getPathsOfIncludedFiles)(includedFiles, includedFilesBasePath);
        const [treeFiles, depFiles] = yield Promise.all([
            (0, tree_files_1.getTreeFiles)(srcPath, stat),
            getDependencies({ featureFlags, functionName: name, mainFile, pluginsModulesPath, srcDir }),
        ]);
        const files = [...treeFiles, ...depFiles].map(path_1.normalize);
        const uniqueFiles = [...new Set(files)];
        // We sort so that the archive's checksum is deterministic.
        // Mutating is fine since `Array.filter()` returns a shallow copy
        const filteredFiles = uniqueFiles.filter(isNotJunk).sort();
        const includedPaths = (0, included_files_1.filterExcludedPaths)([...filteredFiles, ...includedFilePaths], excludedPaths);
        return includedPaths;
    });
};
exports.getSrcFiles = getSrcFiles;
// Remove temporary files like *~, *.swp, etc.
const isNotJunk = function (file) {
    return (0, junk_1.not)((0, path_1.basename)(file));
};
// Retrieve all the files recursively required by a Node.js file
const getDependencies = function ({ featureFlags, functionName, mainFile, pluginsModulesPath, srcDir, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield (0, package_json_1.getPackageJson)(srcDir);
        const state = (0, traversal_cache_1.getNewCache)();
        try {
            return yield getFileDependencies({
                featureFlags,
                functionName,
                path: mainFile,
                packageJson,
                pluginsModulesPath,
                state,
            });
        }
        catch (error) {
            error.message = `In file "${mainFile}"\n${error.message}`;
            throw error;
        }
    });
};
const getFileDependencies = function ({ featureFlags, functionName, path, packageJson, pluginsModulesPath, state, treeShakeNext = false, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (state.localFiles.has(path)) {
            return [];
        }
        state.localFiles.add(path);
        const basedir = (0, path_1.dirname)(path);
        const dependencies = featureFlags.parseWithEsbuild
            ? yield (0, list_imports_1.listImports)({ functionName, path })
            : yield precinct_1.default.paperwork(path, { includeCore: false });
        const depsPaths = yield Promise.all(dependencies.filter(non_nullable_1.nonNullable).map((dependency) => getImportDependencies({
            dependency,
            basedir,
            featureFlags,
            functionName,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext,
        })));
        return depsPaths.flat();
    });
};
const getImportDependencies = function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    const shouldTreeShakeNext = treeShakeNext || isNextOnNetlify(dependency);
    if ((0, tree_shake_1.shouldTreeShake)(dependency, shouldTreeShakeNext)) {
        return getTreeShakedDependencies({
            dependency,
            basedir,
            featureFlags,
            functionName,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext: shouldTreeShakeNext,
        });
    }
    return (0, traverse_1.getDependencyPathsForDependency)({ dependency, basedir, state, packageJson, pluginsModulesPath });
};
const isNextOnNetlify = function (dependency) {
    return (0, path_1.basename)(dependency, '.js') === 'renderNextPage';
};
// When a file requires another one, we apply the top-level logic recursively
const getTreeShakedDependencies = function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = yield (0, resolve_1.resolvePathPreserveSymlinks)(dependency, [basedir, pluginsModulesPath].filter(non_nullable_1.nonNullable));
        const depsPath = yield getFileDependencies({
            featureFlags,
            functionName,
            path,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext,
        });
        return [path, ...depsPath];
    });
};
/* eslint-enable max-lines */
//# sourceMappingURL=src_files.js.map