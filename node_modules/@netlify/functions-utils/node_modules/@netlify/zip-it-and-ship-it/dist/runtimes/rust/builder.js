"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const make_dir_1 = __importDefault(require("make-dir"));
const tmp_promise_1 = __importDefault(require("tmp-promise"));
const toml_1 = __importDefault(require("toml"));
const fs_2 = require("../../utils/fs");
const shell_1 = require("../../utils/shell");
const constants_1 = require("./constants");
const pReadFile = (0, util_1.promisify)(fs_1.readFile);
const runtimeName = 'rs';
const build = ({ config, name, srcDir }) => __awaiter(void 0, void 0, void 0, function* () {
    const functionName = (0, path_1.basename)(srcDir);
    try {
        yield installToolchainOnce();
    }
    catch (error) {
        error.customErrorInfo = { type: 'functionsBundling', location: { functionName, runtime: runtimeName } };
        throw error;
    }
    const targetDirectory = yield getTargetDirectory({ config, name });
    yield cargoBuild({ functionName, srcDir, targetDirectory });
    // By default, the binary will have the same name as the crate and there's no
    // way to override it (https://github.com/rust-lang/cargo/issues/1706). We
    // must extract the crate name from the manifest and use it to form the path
    // to the binary.
    const manifest = yield pReadFile((0, path_1.join)(srcDir, constants_1.MANIFEST_NAME), 'utf8');
    const { package: { name: packageName }, } = toml_1.default.parse(manifest);
    const binaryPath = (0, path_1.join)(targetDirectory, constants_1.BUILD_TARGET, 'release', packageName);
    const stat = yield (0, fs_2.lstat)(binaryPath);
    return {
        path: binaryPath,
        stat,
    };
});
exports.build = build;
const cargoBuild = ({ functionName, srcDir, targetDirectory, }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield (0, shell_1.runCommand)('cargo', ['build', '--target', constants_1.BUILD_TARGET, '--release'], {
            cwd: srcDir,
            env: {
                CARGO_TARGET_DIR: targetDirectory,
            },
        });
    }
    catch (error) {
        const hasToolchain = yield checkRustToolchain();
        if (hasToolchain) {
            console.error(`Could not compile Rust function ${functionName}:\n`);
        }
        else {
            error.message =
                'There is no Rust toolchain installed. Visit https://ntl.fyi/missing-rust-toolchain for more information.';
        }
        error.customErrorInfo = { type: 'functionsBundling', location: { functionName, runtime: runtimeName } };
        throw error;
    }
});
const checkRustToolchain = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield (0, shell_1.runCommand)('cargo', ['-V']);
        return true;
    }
    catch (_) {
        return false;
    }
});
// Returns the path of the Cargo target directory.
const getTargetDirectory = ({ config, name }) => __awaiter(void 0, void 0, void 0, function* () {
    const { rustTargetDirectory } = config;
    // If the config includes a `rustTargetDirectory` path, we'll use that.
    if (rustTargetDirectory) {
        // We replace the [name] placeholder with the name of the function.
        const path = rustTargetDirectory.replace(/\[name]/g, name);
        yield (0, make_dir_1.default)(path);
        return path;
    }
    // If the directory hasn't been configured, we'll use a temporary directory.
    const { path } = yield tmp_promise_1.default.dir();
    return path;
});
let toolchainInstallation;
// Sets the default toolchain and installs the build target defined in
// `BUILD_TARGET`. The Promise is saved to `toolchainInstallation`, so
// that we run the command just once for multiple Rust functions.
const installToolchain = () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, shell_1.runCommand)('rustup', ['default', 'stable']);
    yield (0, shell_1.runCommand)('rustup', ['target', 'add', constants_1.BUILD_TARGET]);
});
const installToolchainOnce = () => {
    if (toolchainInstallation === undefined) {
        toolchainInstallation = installToolchain();
    }
    return toolchainInstallation;
};
//# sourceMappingURL=builder.js.map