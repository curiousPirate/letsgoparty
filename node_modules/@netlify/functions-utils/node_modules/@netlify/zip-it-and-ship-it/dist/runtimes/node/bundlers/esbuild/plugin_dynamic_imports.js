"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDynamicImportsPlugin = void 0;
const path_1 = require("path");
const find_up_1 = __importDefault(require("find-up"));
const read_package_json_fast_1 = __importDefault(require("read-package-json-fast"));
const unixify_1 = __importDefault(require("unixify"));
const parser_1 = require("../../parser");
// This plugin intercepts module imports using dynamic expressions and does a
// couple of things with them. First of all, it figures out whether the call
// is being made from within a Node module, and if so it adds the name of the
// module to `moduleNames`, so that we can warn the user of potential runtime
// issues. Secondly, it parses the dynamic expressions and tries to include in
// the bundle all the files that are possibly needed to make the import work at
// runtime. This is not always possible, but we do our best.
const getDynamicImportsPlugin = ({ basePath, includedPaths, moduleNames, processImports, srcDir, }) => ({
    name: 'dynamic-imports',
    setup(build) {
        const cache = new Map();
        // eslint-disable-next-line complexity
        build.onDynamicImport({ filter: /.*/ }, (args) => __awaiter(this, void 0, void 0, function* () {
            const { expression, resolveDir } = args;
            // Don't attempt to parse the expression if the base path isn't defined,
            // since we won't be able to generate the globs for the included paths.
            // Also don't parse the expression if we're not interested in processing
            // the dynamic import expressions.
            if (basePath && processImports) {
                const { includedPathsGlob, type: expressionType } = (0, parser_1.parseExpression)({ basePath, expression, resolveDir }) || {};
                if (includedPathsGlob) {
                    // The parser has found a glob of paths that should be included in the
                    // bundle to make this import work, so we add it to `includedPaths`.
                    includedPaths.add(includedPathsGlob);
                    // Create the shim that will handle the import at runtime.
                    const contents = getShimContents({ expressionType, resolveDir, srcDir });
                    // This is the only branch where we actually solve a dynamic import.
                    // eslint-disable-next-line max-depth
                    if (contents) {
                        return {
                            contents,
                        };
                    }
                }
            }
            // If we're here, it means we weren't able to solve the dynamic import.
            // We add it to the list of modules with dynamic imports, which allows
            // consumers like Netlify Build or CLI to advise users on how to proceed.
            yield registerModuleWithDynamicImports({ cache, moduleNames, resolveDir, srcDir });
        }));
    },
});
exports.getDynamicImportsPlugin = getDynamicImportsPlugin;
const getPackageName = ({ resolveDir, srcDir }) => __awaiter(void 0, void 0, void 0, function* () {
    const packageJsonPath = yield (0, find_up_1.default)((directory) => __awaiter(void 0, void 0, void 0, function* () {
        // We stop traversing if we're about to leave the boundaries of the
        // function directory or any node_modules directory.
        if (directory === srcDir || (0, path_1.basename)(directory) === 'node_modules') {
            return find_up_1.default.stop;
        }
        const path = (0, path_1.join)(directory, 'package.json');
        const hasPackageJson = yield find_up_1.default.exists(path);
        return hasPackageJson ? path : undefined;
    }), { cwd: resolveDir });
    if (packageJsonPath !== undefined) {
        const { name } = yield (0, read_package_json_fast_1.default)(packageJsonPath);
        return name;
    }
});
const getPackageNameCached = ({ cache, resolveDir, srcDir, }) => {
    if (!cache.has(resolveDir)) {
        cache.set(resolveDir, getPackageName({ resolveDir, srcDir }));
    }
    return cache.get(resolveDir);
};
const getShimContents = ({ expressionType, resolveDir, srcDir, }) => {
    // The shim needs to modify the path of the import, since originally it was
    // relative to wherever the importer sat in the file tree (i.e. anywhere in
    // the user space or inside `node_modules`), but at runtime paths must be
    // relative to the main bundle file, since esbuild will flatten everything
    // into a single file.
    const relativeResolveDir = (0, path_1.relative)(srcDir, resolveDir);
    const requireArg = relativeResolveDir ? `\`./${(0, unixify_1.default)(relativeResolveDir)}/$\{args}\`` : 'args';
    if (expressionType === 'require') {
        return `module.exports = args => require(${requireArg})`;
    }
};
const registerModuleWithDynamicImports = ({ cache, moduleNames, resolveDir, srcDir, }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const packageName = yield getPackageNameCached({ cache, resolveDir, srcDir });
        if (packageName !== undefined) {
            moduleNames.add(packageName);
        }
    }
    catch (_) {
        // no-op
    }
});
//# sourceMappingURL=plugin_dynamic_imports.js.map