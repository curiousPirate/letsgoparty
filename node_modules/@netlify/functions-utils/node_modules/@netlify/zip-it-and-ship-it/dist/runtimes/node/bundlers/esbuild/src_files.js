"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSrcFiles = void 0;
const included_files_1 = require("../../utils/included_files");
const package_json_1 = require("../../utils/package_json");
const traversal_cache_1 = require("../../utils/traversal_cache");
const traverse_1 = require("../zisi/traverse");
const getSrcFiles = ({ config, mainFile, pluginsModulesPath, srcDir }) => __awaiter(void 0, void 0, void 0, function* () {
    const { externalNodeModules = [], includedFiles = [], includedFilesBasePath } = config;
    const { exclude: excludedPaths, paths: includedFilePaths } = yield (0, included_files_1.getPathsOfIncludedFiles)(includedFiles, includedFilesBasePath);
    const dependencyPaths = yield getSrcFilesForDependencies({
        dependencies: externalNodeModules,
        basedir: srcDir,
        pluginsModulesPath,
    });
    const includedPaths = (0, included_files_1.filterExcludedPaths)([...dependencyPaths, ...includedFilePaths], excludedPaths);
    return [...includedPaths, mainFile];
});
exports.getSrcFiles = getSrcFiles;
const getSrcFilesForDependencies = function ({ dependencies: dependencyNames, basedir, state = (0, traversal_cache_1.getNewCache)(), pluginsModulesPath, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (dependencyNames.length === 0) {
            return [];
        }
        const packageJson = yield (0, package_json_1.getPackageJson)(basedir);
        const dependencies = yield Promise.all(dependencyNames.map((dependencyName) => getSrcFilesForDependency({
            dependency: dependencyName,
            basedir,
            state,
            packageJson,
            pluginsModulesPath,
        })));
        const paths = new Set(dependencies.flat());
        return [...paths];
    });
};
const getSrcFilesForDependency = function ({ dependency, basedir, state = (0, traversal_cache_1.getNewCache)(), packageJson, pluginsModulesPath, }) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const paths = yield (0, traverse_1.getDependencyPathsForDependency)({ dependency, basedir, state, packageJson, pluginsModulesPath });
            return paths;
        }
        catch (error) {
            if (error.code === 'MODULE_NOT_FOUND') {
                return [];
            }
            throw error;
        }
    });
};
//# sourceMappingURL=src_files.js.map