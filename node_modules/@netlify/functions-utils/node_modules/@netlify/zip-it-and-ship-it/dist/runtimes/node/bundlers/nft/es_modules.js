"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpileESM = void 0;
const path_1 = require("path");
const fs_1 = require("../../../../utils/fs");
const transpile_1 = require("./transpile");
const getPatchedESMPackages = (packages, fsCache) => __awaiter(void 0, void 0, void 0, function* () {
    const patchedPackages = yield Promise.all(packages.map((path) => patchESMPackage(path, fsCache)));
    const patchedPackagesMap = new Map();
    packages.forEach((packagePath, index) => {
        patchedPackagesMap.set(packagePath, patchedPackages[index]);
    });
    return patchedPackagesMap;
});
const patchESMPackage = (path, fsCache) => __awaiter(void 0, void 0, void 0, function* () {
    const file = (yield (0, fs_1.cachedReadFile)(fsCache, path, 'utf8'));
    const packageJson = JSON.parse(file);
    const patchedPackageJson = Object.assign(Object.assign({}, packageJson), { type: 'commonjs' });
    return JSON.stringify(patchedPackageJson);
});
const shouldTranspile = (path, cache, esmPaths, reasons) => {
    if (cache.has(path)) {
        return cache.get(path);
    }
    const reason = reasons.get(path);
    // This isn't an expected case, but if the path doesn't exist in `reasons` we
    // don't transpile it.
    if (reason === undefined) {
        cache.set(path, false);
        return false;
    }
    const { parents } = reason;
    // If the path is an entrypoint, we transpile it only if it's an ESM file.
    if (parents.size === 0) {
        const isESM = esmPaths.has(path);
        cache.set(path, isESM);
        return isESM;
    }
    // The path should be transpiled if every parent will also be transpiled, or
    // if there is no parent.
    const shouldTranspilePath = [...parents].every((parentPath) => shouldTranspile(parentPath, cache, esmPaths, reasons));
    cache.set(path, shouldTranspilePath);
    return shouldTranspilePath;
};
const transpileESM = ({ basePath, config, esmPaths, fsCache, reasons, }) => __awaiter(void 0, void 0, void 0, function* () {
    const cache = new Map();
    const pathsToTranspile = [...esmPaths].filter((path) => shouldTranspile(path, cache, esmPaths, reasons));
    const pathsToTranspileSet = new Set(pathsToTranspile);
    const packageJsonPaths = [...reasons.entries()]
        .filter(([path, reason]) => {
        if ((0, path_1.basename)(path) !== 'package.json') {
            return false;
        }
        const needsPatch = [...reason.parents].some((parentPath) => pathsToTranspileSet.has(parentPath));
        return needsPatch;
    })
        .map(([path]) => (basePath ? (0, path_1.resolve)(basePath, path) : (0, path_1.resolve)(path)));
    const rewrites = yield getPatchedESMPackages(packageJsonPaths, fsCache);
    yield Promise.all(pathsToTranspile.map((path) => __awaiter(void 0, void 0, void 0, function* () {
        const absolutePath = basePath ? (0, path_1.resolve)(basePath, path) : (0, path_1.resolve)(path);
        const transpiled = yield (0, transpile_1.transpile)(absolutePath, config);
        rewrites.set(absolutePath, transpiled);
    })));
    return rewrites;
});
exports.transpileESM = transpileESM;
//# sourceMappingURL=es_modules.js.map