"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const cp_file_1 = __importDefault(require("cp-file"));
const bundlers_1 = require("./bundlers");
const finder_1 = require("./finder");
const detect_es_module_1 = require("./utils/detect_es_module");
const plugin_modules_path_1 = require("./utils/plugin_modules_path");
const zip_1 = require("./utils/zip");
// We use ZISI as the default bundler, except for certain extensions, for which
// esbuild is the only option.
const getDefaultBundler = ({ extension, mainFile, featureFlags, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { defaultEsModulesToEsbuild, traceWithNft } = featureFlags;
    if (['.mjs', '.ts'].includes(extension)) {
        return 'esbuild';
    }
    if (traceWithNft) {
        return 'nft';
    }
    if (defaultEsModulesToEsbuild) {
        const isEsModule = yield (0, detect_es_module_1.detectEsModule)({ mainFile });
        if (isEsModule) {
            return 'esbuild';
        }
    }
    return 'zisi';
});
// A proxy for the `getSrcFiles` function which adds a default `bundler` using
// the `getDefaultBundler` function.
const getSrcFilesWithBundler = (parameters) => __awaiter(void 0, void 0, void 0, function* () {
    const pluginsModulesPath = yield (0, plugin_modules_path_1.getPluginsModulesPath)(parameters.srcDir);
    const bundlerName = parameters.config.nodeBundler ||
        (yield getDefaultBundler({
            extension: parameters.extension,
            featureFlags: parameters.featureFlags,
            mainFile: parameters.mainFile,
        }));
    const bundler = (0, bundlers_1.getBundler)(bundlerName);
    return bundler.getSrcFiles(Object.assign(Object.assign({}, parameters), { pluginsModulesPath }));
});
const zipFunction = function ({ archiveFormat, basePath, config = {}, destFolder, extension, featureFlags, filename, mainFile, name, repositoryRoot, runtime, srcDir, srcPath, stat, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const pluginsModulesPath = yield (0, plugin_modules_path_1.getPluginsModulesPath)(srcDir);
        const bundlerName = config.nodeBundler || (yield getDefaultBundler({ extension, mainFile, featureFlags }));
        const bundler = (0, bundlers_1.getBundler)(bundlerName);
        // If the file is a zip, we assume the function is bundled and ready to go.
        // We simply copy it to the destination path with no further processing.
        if (extension === '.zip') {
            const destPath = (0, path_1.join)(destFolder, filename);
            yield (0, cp_file_1.default)(srcPath, destPath);
            return { config, path: destPath };
        }
        const { aliases = new Map(), cleanupFunction, basePath: finalBasePath, bundlerWarnings, inputs, mainFile: finalMainFile = mainFile, nativeNodeModules, nodeModulesWithDynamicImports, rewrites, srcFiles, } = yield bundler.bundle({
            basePath,
            config,
            extension,
            featureFlags,
            filename,
            mainFile,
            name,
            pluginsModulesPath,
            repositoryRoot,
            runtime,
            srcDir,
            srcPath,
            stat,
        });
        (0, plugin_modules_path_1.createAliases)(srcFiles, pluginsModulesPath, aliases, finalBasePath);
        const zipPath = yield (0, zip_1.zipNodeJs)({
            aliases,
            archiveFormat,
            basePath: finalBasePath,
            destFolder,
            extension,
            filename,
            mainFile: finalMainFile,
            rewrites,
            srcFiles,
        });
        yield (cleanupFunction === null || cleanupFunction === void 0 ? void 0 : cleanupFunction());
        return {
            bundler: bundlerName,
            bundlerWarnings,
            config,
            inputs,
            nativeNodeModules,
            nodeModulesWithDynamicImports,
            path: zipPath,
        };
    });
};
const zipWithFunctionWithFallback = (_a) => __awaiter(void 0, void 0, void 0, function* () {
    var { config = {} } = _a, parameters = __rest(_a, ["config"]);
    // If a specific JS bundler version is specified, we'll use it.
    if (config.nodeBundler !== 'esbuild_zisi') {
        return zipFunction(Object.assign(Object.assign({}, parameters), { config }));
    }
    // Otherwise, we'll try to bundle with esbuild and, if that fails, fallback
    // to zisi.
    try {
        return yield zipFunction(Object.assign(Object.assign({}, parameters), { config: Object.assign(Object.assign({}, config), { nodeBundler: 'esbuild' }) }));
    }
    catch (esbuildError) {
        try {
            const data = yield zipFunction(Object.assign(Object.assign({}, parameters), { config: Object.assign(Object.assign({}, config), { nodeBundler: 'zisi' }) }));
            return Object.assign(Object.assign({}, data), { bundlerErrors: esbuildError.errors });
        }
        catch (zisiError) {
            throw esbuildError;
        }
    }
});
const runtime = {
    findFunctionsInPaths: finder_1.findFunctionsInPaths,
    getSrcFiles: getSrcFilesWithBundler,
    name: 'js',
    zipFunction: zipWithFunctionWithFallback,
};
exports.default = runtime;
//# sourceMappingURL=index.js.map